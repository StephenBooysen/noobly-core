"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serialize = void 0;
var quote = function (value, quotes) {
    if (quotes === 'double') {
        return "\"".concat(value, "\"");
    }
    if (quotes === 'single') {
        return "'".concat(value, "'");
    }
    return value;
};
var serializeExpression = function (expression) {
    if (expression.type === 'LiteralExpression') {
        if (expression.quoted && typeof expression.value === 'string') {
            return quote(expression.value, expression.quotes);
        }
        return String(expression.value);
    }
    if (expression.type === 'RegexExpression') {
        return String(expression.value);
    }
    if (expression.type === 'RangeExpression') {
        var _a = expression.range, min = _a.min, max = _a.max, minInclusive = _a.minInclusive, maxInclusive = _a.maxInclusive;
        return "".concat(minInclusive ? '[' : '{').concat(min, " TO ").concat(max).concat(maxInclusive ? ']' : '}');
    }
    if (expression.type === 'EmptyExpression') {
        return '';
    }
    throw new Error('Unexpected AST type.');
};
var serializeTag = function (ast) {
    if (ast.type !== 'Tag') {
        throw new Error('Expected a tag expression.');
    }
    var field = ast.field, expression = ast.expression, operator = ast.operator;
    if (field.type === 'ImplicitField') {
        return serializeExpression(expression);
    }
    var left = field.quoted ? quote(field.name, field.quotes) : field.name;
    var patEnd = ' '.repeat(expression.location.start - operator.location.end);
    return left + operator.operator + patEnd + serializeExpression(expression);
};
var serialize = function (ast) {
    if (ast.type === 'ParenthesizedExpression') {
        if (!('location' in ast.expression)) {
            throw new Error('Expected location in expression.');
        }
        if (!ast.location.end) {
            throw new Error('Expected location end.');
        }
        var patStart = ' '.repeat(ast.expression.location.start - (ast.location.start + 1));
        var patEnd = ' '.repeat(ast.location.end - ast.expression.location.end - 1);
        return "(".concat(patStart).concat((0, exports.serialize)(ast.expression)).concat(patEnd, ")");
    }
    if (ast.type === 'Tag') {
        return serializeTag(ast);
    }
    if (ast.type === 'LogicalExpression') {
        var operator = '';
        if (ast.operator.type === 'BooleanOperator') {
            operator += ' '.repeat(ast.operator.location.start - ast.left.location.end);
            operator += ast.operator.operator;
            operator += ' '.repeat(ast.right.location.start - ast.operator.location.end);
        }
        else {
            operator = ' '.repeat(ast.right.location.start - ast.left.location.end);
        }
        return "".concat((0, exports.serialize)(ast.left)).concat(operator).concat((0, exports.serialize)(ast.right));
    }
    if (ast.type === 'UnaryOperator') {
        return (ast.operator === 'NOT' ? 'NOT ' : ast.operator) + (0, exports.serialize)(ast.operand);
    }
    if (ast.type === 'EmptyExpression') {
        return '';
    }
    throw new Error('Unexpected AST type.');
};
exports.serialize = serialize;
